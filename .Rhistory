library(janitor)
library(magrittr)
library(reshape)
library(dplyr)
library(tidyr)
library(ggplot2)
library(caTools)
library(neuralnet)
library(caret)
library(gbm)
library(pROC)
seed <- 123
df_bl <- read.csv("C:/Users/jessb/OneDrive/MS-CB/Data science II/Project/baselines.csv",
header = TRUE, sep = ",", stringsAsFactors = TRUE)
#head(df_bl)
## clean names
colnames(df_bl)[which(colnames(df_bl) == "sex.factor")] <- "sex"
colnames(df_bl)[which(colnames(df_bl) == "hypoxia_ed.factor")] <- "hypoxia"
colnames(df_bl)[which(colnames(df_bl) == "dm.factor")] <- "diabetes"
colnames(df_bl)[which(colnames(df_bl) == "htn.factor")] <- "hypertension"
colnames(df_bl)[which(colnames(df_bl) == "pulm___1.factor")] <- "copd"
colnames(df_bl)[which(colnames(df_bl) == "renal___1.factor")] <- "ckd"
colnames(df_bl)[which(colnames(df_bl) == "renal___2.factor")] <- "esrd"
colnames(df_bl)[which(colnames(df_bl) == "cad.factor")] <- "cad"
colnames(df_bl)[which(colnames(df_bl) == "symptoms___1.factor")] <- "fever"
colnames(df_bl)[which(colnames(df_bl) == "symptoms___2.factor")] <- "cough"
colnames(df_bl)[which(colnames(df_bl) == "symptoms___10.factor")] <- "diarrhea"
colnames(df_bl)[which(colnames(df_bl) == "symptoms___9.factor")] <- "nausea_vomit"
colnames(df_bl)[which(colnames(df_bl) == "symptoms___8.factor")] <- "myalgias"
colnames(df_bl)[which(colnames(df_bl) == "symptoms___3.factor")] <- "dyspnea"
colnames(df_bl)[which(colnames(df_bl) == "first_cxr_results___0.factor")] <-
"xray_clear"
colnames(df_bl)[which(colnames(df_bl) == "first_cxr_results___1.factor")] <-
"xray_unilateral_infiltrate"
colnames(df_bl)[which(colnames(df_bl) == "first_cxr_results___2.factor")] <-
"xray_bilateral_infiltrates"
colnames(df_bl)[which(colnames(df_bl) == "first_cxr_results___3.factor")] <-
"xray_pleural_effusion"
df_bl <- clean_names(df_bl)
## find columns that need to be releveled so reference is "Unchecked"
idx_check <- which(colnames(df_bl) %in%
names(unlist(apply(df_bl[1, ], 2,function(x) grep("heck",x)))))
#apply(df_bl[, idx_check], 2, function(x) unique(x))
for (n in idx_check){
df_bl[, n] <- relevel(df_bl[, n], "Unchecked")
}
## find columns with "Yes/No" responses
idx_cont <- which(sapply(df_bl, function(x) is.numeric(x)) == TRUE)
remove <- c(idx_check, idx_cont)
idx_yn <- seq(length(df_bl))
idx_yn <- idx_yn[! idx_yn %in% remove]
idx_yn <- idx_yn[-1]
str(df_bl)
## table colsum for NA; use one or the other
#data.frame(count_na = apply(df_bl, 2, function(x) sum(is.na(x))))
#data.frame(colSums(is.na(df_bl)))
## creates list of counts of all categorical variables
#select(df_bl, -c(mrn, age, bmi, duration_symptoms)) %>%
#  apply(., 2, function(x) data.frame(table(x)))
## create list of all categorical variables by event
ct_outcome <- select(df_bl, -c(mrn, age, bmi, duration_symptoms)) %>%
apply(., 2, function(x) data.frame(table(df_bl$event, x)))
for (n in 1:length(ct_outcome)){
names(ct_outcome[[n]])[2] <- names(ct_outcome[n])
}
for (n in 1:length(ct_outcome)){
names(ct_outcome[[n]])[1] <- "Event"
}
## create bar charts for all categorical variables by event
#lapply(ct_outcome, function(y) ggplot(y, aes(fill=Var1, y=Freq,
#                                             x=get(names(y)[2]))) +
#         geom_bar(position="dodge", stat="identity") +
#         xlab(names(y)[2]))
ggplot(ct_outcome[[1]], aes(fill=Event, y=Freq, x=get(names(ct_outcome[[1]])[2]))) +
geom_bar(position="dodge", stat="identity") +
xlab(names(ct_outcome[[1]])[2])
## Plot Checked/Unchecked variables
df_ct_yn <- apply(df_bl[, idx_yn], 2,
function(x) table(df_bl[, length(df_bl)], x))
df_ct_yn <- melt(df_ct_yn)
colnames(df_ct_yn) <- c("Event", "Variable", "Freq")
df_ct_yn$Event <- rep(c("No", "Yes"))
df_ct_yn$Value <- rep(c(rep("No", 2), rep("Yes", 2)))
ggplot(df_ct_yn, aes(x = Value, y = Freq, fill = Event)) +
geom_bar(position="dodge", stat="identity") +
facet_wrap(~Variable)
## plot Y/N variables
df_ct_check <- apply(df_bl[, idx_check], 2,
function(x) table(df_bl[, length(df_bl)], x))
df_ct_check <- melt(df_ct_check)
colnames(df_ct_check) <- c("Event", "Variable", "Freq")
df_ct_check$Event <- rep(c("No", "Yes"))
df_ct_check$Value <- rep(c(rep("Checked", 2), rep("Unchecked", 2)))
ggplot(df_ct_check, aes(x = Value, y = Freq, fill = Event)) +
geom_bar(position="dodge", stat="identity") +
facet_wrap(~Variable)
## table of summary of continuous variables
#df_bl[, c(idx_cont, length(df_bl))] %>%
select(df_bl, c(mrn, age, bmi, duration_symptoms)) %>%
apply(., 2, function(x) summary(x)) %>%
knitr::kable()
## remove row where patient age < 0
#df_bl$mrn[which(df_bl$age < 0)]
df_bl <- df_bl[-which(df_bl$age < 0),]
## create histograms for quantitative variables
df_bl[, c(idx_cont, length(df_bl))] %>%
#  select(c(mrn, age, bmi, duration_symptoms, event)) %>%
melt(., id = c("mrn", "event")) %>%
ggplot(aes(value, group = event, col = event)) +
geom_histogram(bins = 10) +
facet_wrap(~variable, scales = "free")
load(file = "C:/Users/jessb/OneDrive/MS-CB/Data science II/Project/labs.Rda")
ggplot(df_labs, aes(x = time,
y = value,
color = event)) +
geom_line() +
facet_grid(name~event)
#ggplot(df_labs, aes(x = time,
#                    y = value,
#                    group = subject,
#                    color = as.factor(subject))) +
#  geom_line() +
#  facet_wrap(event~name)
aggregate(df_labs$value, list(df_labs$event, df_labs$name), mean)
df_mean_subject <- aggregate(df_labs$value,
list(df_labs$subject, df_labs$name), mean)
df_mean_subject <- spread(df_mean_subject, Group.2, x)
colnames(df_mean_subject)[1] <- "subject"
df_combo <- merge(df_bl, df_mean_subject,
by.x = "mrn", by.y = "subject",
all.x = TRUE, all.y = TRUE)
df_long <- df_combo %>%
select(colnames(df_combo)[c(1, 27:32)])
df_long <- melt(df_long, id.vars = c("mrn", "event"))
ggplot(df_long, aes(x = value, col = as.factor(event), group = event)) +
geom_histogram(bins = 10) +
facet_grid(~variable, scales = "free")
## add integer event to combo df
df_combo$event.int <- ifelse(df_combo$event == "Yes", 1, 0)
## convert categorical variables to hot-one encoding
df_combo_rev <- df_combo
df_combo_rev[ , idx_check] <- apply(df_combo_rev[ , idx_check], 2,
function(x) ifelse(x == "Checked", 1, 0))
df_combo_rev[ , idx_yn] <- apply(df_combo_rev[ , idx_yn], 2,
function(x) ifelse(x == "Yes", 1, 0))
df_combo_rev$sex <- ifelse(df_combo_rev$sex == "Male", 1, 0)
str(df_combo_rev)
set.seed(seed)
sample <- sample.split(df_combo, SplitRatio = 0.75)
train <- subset(df_combo, sample == TRUE)
test <- subset(df_combo, sample == FALSE)
## GridSearch grid
caretGrid.gbm <- expand.grid(interaction.depth = c(1, 2),
n.trees = seq(1000, 5000, by = 1000),
shrinkage = seq(0, 0.01, by = 0.001),
n.minobsinnode = 10)
## fit model using grid search
gbm.train <- caret::train(event ~ . - event - event.int - mrn,data = train,
distribution = "bernoulli", method = "gbm",
trControl = trainControl(method="cv", number=5),
verbose = TRUE, tuneGrid = caretGrid.depth.1)
## fit model using grid search
gbm.train <- caret::train(event ~ . - event - event.int - mrn,data = train,
distribution = "bernoulli", method = "gbm",
trControl = trainControl(method="cv", number=5),
verbose = TRUE, tuneGrid = caretGrid.gbm)
cat("The optimal shrinkage parameter is", gbm.train$bestTune$shrinkage,
"out of the range of", min(caretGrid.gbm$shrinkage), "-",
max(caretGrid.gbm$shrinkage), "tested.\n")
cat("The optimal number of trees is", gbm.train$bestTune$n.trees,
"out of the range of", min(caretGrid.gbm$n.trees), "-",
max(caretGrid.gbm$n.trees), "tested.\n")
cat("The optimal interaction depth is", gbm.train$bestTune$interaction.depth,
"out of the range of", min(caretGrid.gbm$interaction.depth), "-",
max(caretGrid.gbm$interaction.depth), "tested.")
gbm.fit <- gbm(event.int ~ . - event - event.int - mrn, data = train,
n.trees = gbm.train$bestTune$n.trees,
interaction.depth = gbm.train$bestTune$interaction.depth,
shrinkage = gbm.train$bestTune$shrinkage,
distribution = 'bernoulli')
summary(gbm.fit)
n_tree <- 500
predict.gbm <- predict(gbm.fit,
newdata = test,
n.trees = n_tree,
type = "response")
predict.gbm <- ifelse(predict.gbm > 0.5, 1, 0)
confusionMatrix(as.factor(test$event.int), as.factor(predict.gbm))
as.data.frame(summary(gbm.fit))
knitr::kable(as.data.frame(summary(gbm.fit)))
knitr::kable(as.data.frame(summary(gbm.fit))[, 2:3])
as.data.frame(summary(gbm.fit))[, 2:3]
dim(as.data.frame(summary(gbm.fit)))
as.data.frame(summary(gbm.fit))
data.frame(summary(gbm.fit))
summary(gbm.fit)
gbm.fit <- gbm(event.int ~ . - event - event.int - mrn, data = train,
n.trees = gbm.train$bestTune$n.trees,
interaction.depth = gbm.train$bestTune$interaction.depth,
shrinkage = gbm.train$bestTune$shrinkage,
distribution = 'bernoulli')
summary(gbm.fit)
df_gbm <- summary(gbm.fit)
df_gbm$var
df_gbm[, 2:3]
df_gbm[, 1:2]
rownames(df_gbm)
rownames(df_gbm) <- c()
knitr::kable(df_gbm)
n_tree <- 500
predict.gbm <- predict(gbm.fit,
newdata = test,
n.trees = n_tree,
type = "response")
predict.gbm <- ifelse(predict.gbm > 0.5, 1, 0)
confusionMatrix(as.factor(test$event.int), as.factor(predict.gbm))
predict.gbm <- ifelse(predict.gbm > 0.5, 1, 0)
confusionMatrix(as.factor(test$event.int), as.factor(predict.gbm))
acc.gbm <- mean(predict.gbm != test$event.int)
acc.gbm
acc.gbm <- 1-mean(predict.gbm != test$event.int)
acc.gbm
probs.gbm <- predict(gbm.train,
newdata = test,
n.trees = n_trees,
type = "prob")
roc.gbm <- roc(test$event, gbm.probs$Yes)
roc.gbm <- roc(test$event, probs.gbm$Yes)
auc.gbm <- gbm.roc.area(test$event.int, predict.gbm)
plot.roc(roc.gbm,
print.auc = TRUE,
add = TRUE,
#         print.auc.y = 0.65,
col = "green")
plot.new()
plot.roc(roc.gbm,
print.auc = TRUE,
add = TRUE,
#         print.auc.y = 0.65,
col = "green")
summary(gbm.fit)
plot.roc(roc.gbm,
print.auc = TRUE,
add = TRUE,
#         print.auc.y = 0.65,
col = "green")
ggplot(ct_outcome[[1]], aes(fill=Event, y=Freq, x=get(names(ct_outcome[[1]])[2]))) +
geom_bar(position="dodge", stat="identity") +
xlab(names(ct_outcome[[1]])[2])
plot.roc(roc.gbm,
print.auc = TRUE,
add = TRUE,
#         print.auc.y = 0.65,
col = "green")
plot(roc.gbm,
print.auc = TRUE,
add = TRUE,
#         print.auc.y = 0.65,
col = "green")
roc.gbm <- roc(test$event, probs.gbm$Yes,
print.auc = TRUE,
#               print.auc.y = 0.65,
add = TRUE)
roc.gbm <- roc(test$event, probs.gbm$Yes,
print.auc = TRUE)
plot(roc.gbm, add = TRUE, col = "blue")
roc.gbm <- roc(test$event, probs.gbm$Yes,
print.auc = TRUE)
roc.gbm <- roc(test$event, probs.gbm$Yes,
print.auc = TRUE)
dev.off()
plot(roc.gbm, add = TRUE, col = "blue")
par(mfrow = c(1, 2))
plot(roc.gbm, add = TRUE, col = "blue")
plot.new()
plot(roc.gbm, add = TRUE, col = "blue")
plot(roc.gbm, add = TRUE, col = "blue", print.auc = TRUE)
dev.off()
dev.off()
ggplot(ct_outcome[[1]], aes(fill=Event, y=Freq, x=get(names(ct_outcome[[1]])[2]))) +
geom_bar(position="dodge", stat="identity") +
xlab(names(ct_outcome[[1]])[2])
plot(roc.gbm, add = TRUE, col = "blue", print.auc = TRUE)
plot.new()
plot(roc.gbm, add = TRUE, col = "blue", print.auc = TRUE)
plot(roc.gbm, add = TRUE, col = "blue", print.auc = TRUE, legacy.axes = TRUE)
par(pty = "s")
plot(roc.gbm, add = TRUE, col = "blue", print.auc = TRUE, legacy.axes = TRUE)
plot(roc.gbm,
plot = TRUE, legacy.axes = TRUE,
xlab = "False positive percentage",
ylab = "True positive percentage",
add = TRUE,
col = "blue",
print.auc = TRUE)
plot(roc.gbm,
legacy.axes = TRUE,
xlab = "False positive percentage",
ylab = "True positive percentage",
add = TRUE,
col = "blue",
print.auc = TRUE)
par(pty = "s")
plot(roc.gbm,
plot = TRUE,
legacy.axes = TRUE,
xlab = "False positive percentage",
ylab = "True positive percentage",
add = TRUE,
col = "blue",
print.auc = TRUE)
